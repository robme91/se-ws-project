package level;

import objects.Block;
import objects.GameBorder;
import objects.GameObject;
import objects.House;
import objects.NPC;
import objects.Player;
import objects.Street;
import objects.Character;
import org.newdawn.slick.Graphics;
import utils.GameUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Created by Robin on 08.01.2017.
 * This is a dummy level class for dev. All other level classes musst be generated by codegenerator.
 */
public class DummyLevel implements ILevel {

    public static final String LEVEL_NAME = "Dummy Level";

    /*The player for this level*/
    private Player player;

    /*The time player have to survive in this level in s*/
    private float time;

    private List<Block> blocks;
    private List<Block> blockingBlocks;

    /**
     * List of characters (including the player)
     */
    private List<Character> characters;

    /*creates this level. here all the input of the text file must be used for crating this level*/
    public DummyLevel() {

        /*
         * Level is 800x640 blocks, one block is 32*32 pix... -> Level = 25x20 Blocks
         */

        this.blocks = new ArrayList<Block>();
        this.blockingBlocks = new ArrayList<Block>();
        this.characters = new ArrayList<Character>();

        time = 0.001f;
        //        this.player = new Player(16, 16, 20, true, 1f);
        //        characters.add(player);

        // add borders

        addBlock(new GameBorder(-GameUtils.GAME_FIELD_HEIGHT / 2, GameUtils.GAME_FIELD_HEIGHT /
                2, GameUtils.GAME_FIELD_HEIGHT, true));
        addBlock(new GameBorder(GameUtils.GAME_FIELD_WIDTH + GameUtils.GAME_FIELD_HEIGHT / 2,
                GameUtils.GAME_FIELD_HEIGHT / 2, GameUtils.GAME_FIELD_HEIGHT, true));
        addBlock(new GameBorder(GameUtils.GAME_FIELD_WIDTH / 2, -GameUtils.GAME_FIELD_WIDTH / 2,
                GameUtils.GAME_FIELD_WIDTH, true));
        addBlock(new GameBorder(GameUtils.GAME_FIELD_WIDTH / 2, GameUtils.GAME_FIELD_HEIGHT +
                GameUtils.GAME_FIELD_WIDTH / 2, GameUtils.GAME_FIELD_WIDTH, true));

        // random level init for testing
        for (int x = 16; x < 785; x += 32) {
            for (int y = 16; y < 625; y += 32) {
                if (new Random().nextInt(4) > 2) {
                    addBlock(new House(x, y, 32, true));
                } else {
                    addBlock(new Street(x, y, 32, false));
                    if (this.player == null) {
                        this.player = new Player(x, y, 20, true, 1f, 1f);
                        characters.add(player);
                    }
                    if (new Random().nextInt(20) >= 19) {
                        this.characters.add(new NPC(x, y, 20, true, 0.5f));
                    }
                }
            }
        }
    }


    public Player getPlayer() {
        return player;
    }

    /**
     * Returns null or a List of GameObjects that are touched by character c
     *
     * @param c Character
     * @return null or list of GameObjects
     */
    private List<GameObject> whichBlockingBlocksDoIHit(Character c) {
        List<GameObject> hitObjects = new ArrayList<GameObject>();
        for (GameObject block : blockingBlocks) {
            if (block.isBlocking()) {
                if (block.checkIfHitBy(c.getHitbox())) {
                    hitObjects.add(block);
                }
            }
        }
        for (GameObject character : characters) {  // TODO REMOVE REDUNDANCY
            if (character.isBlocking() && character != c) {
                if (character.checkIfHitBy(c.getHitbox())) {
                    hitObjects.add(character);
                }
            }
        }
        if (hitObjects.isEmpty()) {
            return null;
        } else {
            return hitObjects;
        }
    }


    public float getTime() {
        return time;
    }

    /**
     * Draws all blocks of this map onto a given graphic context
     *
     * @param g Graphics context
     */
    public void drawOnGraphicContext(Graphics g) {
        for (Block b : blocks) {
            if (b.getImage() != null) {
                g.drawImage(b.getImage(), b.getPos_x() - b.getSize() / 2, b.getPos_y() - b
                        .getSize() / 2);
            }
        }

        for (Character c : characters) {
            g.drawImage(c.getImage(), c.getPos_x() - c.getSize() / 2, c.getPos_y() - c.getSize()
                    / 2);
        }
    }

    public void update(int delta) {
        // move Characters
        for (Character c : characters) {
            if (c.getDirection() != null) {
                float oldX = c.getPos_x();
                float oldY = c.getPos_y();
                float newX = oldX;
                float newY = oldY;
                float factor = delta * .1f * c.getSpeed();
                switch (c.getDirection()) {
                    case UP:
                        newY = oldY - factor;
                        break;
                    case DOWN:
                        newY = oldY + factor;
                        break;
                    case LEFT:
                        newX = oldX - factor;
                        break;
                    case RIGHT:
                        newX = oldX + factor;
                        break;
                }
                // set new location and test if this is legal
                c.setLocation(newX, newY);  // TODO set to closest hitpoint
                List<GameObject> hitObjects = whichBlockingBlocksDoIHit(c);
//                List<GeomUtil.HitResult> hitResults = new ArrayList<GeomUtil.HitResult>();
                if (hitObjects != null) {
                    for (GameObject go : hitObjects) {
                        // call interact method on both sides
                        go.interact(c);
                        c.interact(go);
//                         find where we hit the object
//                        Line movementVector = new Line(oldX, oldY, newX, newY);
//                        GeomUtil geomUtil = new GeomUtil();
//                        GeomUtil.HitResult hitResult = geomUtil.intersect(go.getHitbox(),
//                                movementVector);
//                        hitResults.add(hitResult);
                    }
                    c.setLocation(oldX, oldY);

//                    GeomUtil.HitResult minimalHitResult = null;
//                    Vector2f oldPositionPlayer = new Vector2f(oldX, oldY);
//                    for (GeomUtil.HitResult hitResult : hitResults) {
//                        if (minimalHitResult == null || minimalHitResult.pt.distance
//                                (oldPositionPlayer) > hitResult.pt.distance(oldPositionPlayer))
//
//                        {
//                            minimalHitResult = hitResult;
//                        }
//                    }
//                    c.setLocation(minimalHitResult.pt.getX(), minimalHitResult.pt.getY());

                }
            }
        }
    }

    /**
     * Add new block and make shure that blocking blocks get stored in the blockingBlocks list.
     *
     * @param block block to add
     */
    private void addBlock(Block block) {
        System.out.println(block);
        this.blocks.add(block);
        if (block.isBlocking()) {
            this.blockingBlocks.add(block);
        }
    }

}
